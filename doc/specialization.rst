Specialization
==============

**Specialization** is the mechanism through which darlang provides parametric function polymorphism. It can be seen as an analogue to implicitly-generated C++ templates, implementation-wise.

Specialization at work
----------------------

Suppose the existence of an under-constrained function `tuplify`;

.. code-block:: darlang

  tuplify(a) -> (a, a)

Such a function can be observed to impose no constraints on the type of the argument `a`. Since the set of potential types for `tuplify` is infinite, the darlang compiler skips code generation for it in the absence of invocations.

Consider, however, if we had the following invocations:

.. code-block:: darlang

  main() ->
    ds | tuplify("hello");
    is | tuplify(5);
    0

Two **specializations** of `tuplify` are generated by the compiler- one with signature `string -> (string, string)`, and one with signature `i64 -> (i64, i64)`. This reduces the need for runtime typing logic, reducing instruction count at the expense of code size.

.. note::
  Specializations of a function are populated by the darlang compiler by traversing the call graph starting from top-level exports, which possess known types, and enumerating all required implementations.

  IR is generated for each possible specialization of a function, each of which possess a unique symbol name derived from the function's name and its solved argument types.
